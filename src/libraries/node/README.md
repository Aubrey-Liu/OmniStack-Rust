# Node

## Introduction

Node实现了一个从底层的数据报到Socket转换的抽象，同时维护了引用计数，提供了完整的多进程支持。

Node维护了一张从地址到Node结构的哈希表，在如下的事件发生时会对哈希表进行修改：
1. 当用户调用Close对一个Node进行关闭，并且所有到一个Node的引用全部关闭。
2. 当用户对一个Node使用了Connect/Listen/Bind/RecvFrom时
3. 图中的模块抛出了一个事件，申请创建一个Node

同时会根据情况生成如下的事件：

1. Node关闭(TCP/UDP)：当一个Node的所有用户引用全部关闭，此时自顶向下告知`com_user`
2. Node创建失败：当申请创建Node，但是Node无法进入Accept队列，此时等价于情况1，直接Node的所有用户引用关闭事件
3. 对侧关闭(发送给上层)：一个数据为空的包

当一个自底向上的数据报文到达`com_user`时，若该包携带有`node`则直接使用`node->Write(packet)`方法将该包发送到上层。否则根据包头中的信息查询哈希表，若找到对应的`node`则使用`node->Write(packet)`方法递交包。

自顶向下的来自同一个线程的包会通过多写者通道发送到`com_user`

## Detail

自底向上的包为裸数据包

* UDP: 全部为数据报文
* TCP
    * 对侧关闭报文：一个Payload长度为0的报文
    * 数据报文
    * 创建了新的Node

自定向下的数据包会携带一个额外的头，这个头在经过`com_user`后会被去除，标记了几种不同的事件

1. 用户对一个Node调用了特殊的方法，需要修改哈希表
2. 用户需要将一个Node从哈希表中驱除 => Node Closed
3. 一个单纯的数据报文

同时自顶向下的数据包会会自动携带`packet->node_`字段，指向对应的`node`如果为修改哈希表的请求报文，则不会进一步发送给下一个结点。

为了实现正确的用户侧关闭Node，引用计数为0的情况下不能打开新的Socket，并且当引用计数为0时应当立即通知`com_user`，所有的释放都应当由`com_user`执行，以实现正确的内存管理。