# OmniStack

This project is a refactored version of Project [OmniStack C Version](https://github.com/JeremyGuo/CQStack)

OmniStack是一个完全模块化的运行在用户态的网络协议栈

## System Design

整个系统分成三个部分：

1. 共享库
2. 工具库
3. 协议栈

### 工具库

#### 内存管理

实现了内存管理，每个进程在启动的时候会通过pipe，创建一个到控制平面的通道。

进程中的每一个线程启动的时候会向控制平面注册自己的相关信息。

当进程终止或者线程显示关闭的时候，控制平面会自动收回**在这个进程中**的内存资源。

不同的内存类型：

* 本地内存
  通过传统的方法申请获取的内存，内存只能在本地进程中使用，不能跨越进程使用
* 共享内存
  共享内存应当有一个名字，不同进程可以通过相同的名字获取同一片共享内存，这也应当是唯一的获取大块共享内存的方法。
* 内存池内存
  从一个内存池中申请得到的一片区域的内存

#### 基于Token的锁

#### 进程间传输

* 多读者单写者Channel
    利用Token的锁实现对多个读者的加锁
* 多读者多写者Channel 
    利用Token的锁实现对多个读者的加锁；
    多个写者可能同时对Channel写入，利用二叉树更新每个写者的写入事件的方式进行更新；
    同时多个写者利用Batch进行二叉树上的内容更新，所以每次事件更新的复杂度为$\Omega(\frac{\log_2 N}{\text{Batch Size}})$；
    单独一个二叉树维护时间戳？

### 用户库

#### 共享库

使用者可以通过`LD_PRELOAD`实现对原可执行程序的透明迁移。

注意，本系统只实现了对如下符号的替换，如果有其他内核态函数调用会产生如创建、关闭文件描述符的操作可能导致程序无法正常执行。

共享库主要实现了如下内容：

1. 一个全新的文件描述符系统（进程独立），其底层为新的协议栈的node系统（进程间共享）或Linux原有的文件描述符系统。
   > 注意每一个socket的底层是两个不同的node，一个用于接收报文，另一个用于发送报文

   > 用于接收数据的node是一个单读者单写者的模型；
   > 用于模拟epollfd的node是一个多写者多读者的模型 （注意epoll虽然大幅降低了无效轮询产生的CPU开销，但是可能产生一定的性能下降）；
   > 用于发送的node是一个多写者单读者的模型（读者为处理该报文的协议栈线程，写者为不同的进程中的线程）
2. 提供了新的node系统和协议栈通信的通道，每一个node的底层是一个无锁的和协议栈进程通信的通道。

#### 静态库

静态库提供了一套更高效的API可以实现更快的系统调用包括如下的特性：

1. 完全Zero-Copy：开发者可以直接申请一段可以用于DMA的内存，在这段内存上直接写入要发送的数据，可以进一步减少内存的拷贝
2. 原生事件驱动：完全在用户态实现了基于事件驱动的收包和发包

### 协议栈

测试

## Development

本项目基于C++20开发，代码规范参照 [Google 代码规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#section-7)